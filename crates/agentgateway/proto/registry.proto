syntax = "proto3";

package agentgateway.dev.registry;

import "google/protobuf/struct.proto";

option go_package = "github.com/agentgateway/agentgateway/go/api;api";

// Registry is the root container for tool definitions
message Registry {
  // Schema version for compatibility checking
  string schema_version = 1;
  
  // List of tool definitions (virtual tools and compositions)
  repeated ToolDefinition tools = 2;
}

// ToolDefinition represents either a virtual tool (1:1 mapping) or a composition (N:1 orchestration)
message ToolDefinition {
  // Name exposed to agents (unique identifier)
  string name = 1;
  
  // Optional description (for source-based, can inherit from backend)
  optional string description = 2;
  
  // Tool implementation - either source-based or composition
  oneof implementation {
    // Virtual tool: adapts a single backend tool (1:1)
    SourceTool source = 3;
    
    // Composition: orchestrates multiple tools (N:1)
    PatternSpec spec = 4;
  }
  
  // Input schema override (JSON Schema as struct)
  optional google.protobuf.Struct input_schema = 5;
  
  // Output transformation (applies to both virtual tools and compositions)
  optional OutputTransform output_transform = 6;
  
  // Semantic version of this tool definition
  optional string version = 7;
  
  // Arbitrary metadata (owner, classification, etc.)
  map<string, google.protobuf.Value> metadata = 8;
}

// SourceTool defines a 1:1 mapping to a backend tool
message SourceTool {
  // Target name (MCP server/backend name)
  string target = 1;
  
  // Original tool name on that target
  string tool = 2;
  
  // Fields to inject at call time (supports ${ENV_VAR} substitution)
  map<string, google.protobuf.Value> defaults = 3;
  
  // Fields to remove from schema (hidden from agents)
  repeated string hide_fields = 4;
}

// PatternSpec defines a composition pattern
message PatternSpec {
  oneof pattern {
    PipelineSpec pipeline = 1;
    ScatterGatherSpec scatter_gather = 2;
    FilterSpec filter = 3;
    SchemaMapSpec schema_map = 4;
    MapEachSpec map_each = 5;
    // Future patterns: RouterSpec, EnricherSpec, CircuitBreakerSpec, etc.
  }
}

// =============================================================================
// Pipeline Pattern
// =============================================================================

// PipelineSpec executes steps sequentially, passing output to next step
message PipelineSpec {
  repeated PipelineStep steps = 1;
}

message PipelineStep {
  // Unique identifier for this step (for data binding references)
  string id = 1;
  
  // The operation to execute
  StepOperation operation = 2;
  
  // Input binding for this step
  DataBinding input = 3;
}

// StepOperation defines what a step does
message StepOperation {
  oneof op {
    // Call a tool by name (resolved from registry or backend)
    ToolCall tool = 1;
    
    // Inline pattern (no separate name)
    PatternSpec pattern = 2;
  }
}

message ToolCall {
  // Tool name (can be virtual tool, composition, or backend tool)
  string name = 1;
}

// DataBinding specifies where step input comes from
message DataBinding {
  oneof source {
    // From composition input
    InputBinding input = 1;
    
    // From a previous step's output
    StepBinding step = 2;
    
    // Constant value
    google.protobuf.Value constant = 3;
  }
}

message InputBinding {
  // JSONPath into composition input (e.g., "$" for whole input, "$.query" for field)
  string path = 1;
}

message StepBinding {
  // ID of the step to reference
  string step_id = 1;
  
  // JSONPath into step output
  string path = 2;
}

// =============================================================================
// Scatter-Gather Pattern
// =============================================================================

// ScatterGatherSpec fans out to multiple targets in parallel and aggregates results
message ScatterGatherSpec {
  // Targets to invoke in parallel
  repeated ScatterTarget targets = 1;
  
  // How to aggregate results
  AggregationStrategy aggregation = 2;
  
  // Timeout in milliseconds (optional)
  optional uint32 timeout_ms = 3;
  
  // If true, fail immediately on first error; if false, collect partial results
  bool fail_fast = 4;
}

message ScatterTarget {
  oneof target {
    // Tool name (resolved from registry or backend)
    string tool = 1;
    
    // Inline pattern
    PatternSpec pattern = 2;
  }
}

// AggregationStrategy defines how to combine scatter-gather results
message AggregationStrategy {
  // Sequence of operations applied in order
  repeated AggregationOp ops = 1;
}

message AggregationOp {
  oneof op {
    // Flatten array of arrays into single array
    bool flatten = 1;
    
    // Sort by field
    SortOp sort = 2;
    
    // Deduplicate by field
    DedupeOp dedupe = 3;
    
    // Take first N results
    LimitOp limit = 4;
    
    // Keep arrays nested (no flattening)
    bool concat = 5;
    
    // Merge objects (for object results)
    bool merge = 6;
  }
}

message SortOp {
  // JSONPath to the field to sort by
  string field = 1;
  
  // Sort order: "asc" or "desc"
  string order = 2;
}

message DedupeOp {
  // JSONPath to the field to dedupe by
  string field = 1;
}

message LimitOp {
  // Maximum number of results
  uint32 count = 1;
}

// =============================================================================
// Filter Pattern
// =============================================================================

// FilterSpec filters array elements based on a predicate
message FilterSpec {
  // The predicate to evaluate for each element
  FieldPredicate predicate = 1;
}

message FieldPredicate {
  // JSONPath to the field to evaluate
  string field = 1;
  
  // Comparison operator: "eq", "ne", "gt", "gte", "lt", "lte", "contains", "in"
  string op = 2;
  
  // Value to compare against
  PredicateValue value = 3;
}

message PredicateValue {
  oneof value {
    string string_value = 1;
    double number_value = 2;
    bool bool_value = 3;
    bool null_value = 4;  // If true, represents null
    ValueList list_value = 5;  // For "in" operator
  }
}

message ValueList {
  repeated PredicateValue values = 1;
}

// =============================================================================
// Schema Map Pattern
// =============================================================================

// SchemaMapSpec transforms input to output using field mappings
message SchemaMapSpec {
  // Field name -> source mapping
  map<string, FieldSource> mappings = 1;
}

message FieldSource {
  oneof source {
    // JSONPath extraction from input
    string path = 1;
    
    // Constant value
    LiteralValue literal = 2;
    
    // First non-null from multiple paths
    CoalesceSource coalesce = 3;
    
    // String template with variable substitution
    TemplateSource template = 4;
    
    // Concatenate multiple fields
    ConcatSource concat = 5;
    
    // Nested object mapping
    SchemaMapSpec nested = 6;
  }
}

message LiteralValue {
  oneof value {
    string string_value = 1;
    double number_value = 2;
    bool bool_value = 3;
    bool null_value = 4;  // If true, value is null
  }
}

message CoalesceSource {
  // JSONPaths to try in order, returning first non-null
  repeated string paths = 1;
}

message TemplateSource {
  // Template string with {var} placeholders
  string template = 1;
  
  // Variable name -> JSONPath binding
  map<string, string> vars = 2;
}

message ConcatSource {
  // JSONPaths to concatenate
  repeated string paths = 1;
  
  // Separator between values (default: empty string)
  optional string separator = 2;
}

// =============================================================================
// Map Each Pattern
// =============================================================================

// MapEachSpec applies an operation to each element of an array
message MapEachSpec {
  // The operation to apply to each element
  MapEachInner inner = 1;
}

message MapEachInner {
  oneof inner {
    // Tool name to call for each element
    string tool = 1;
    
    // Pattern to apply for each element
    PatternSpec pattern = 2;
  }
}

// =============================================================================
// Output Transform
// =============================================================================

// OutputTransform defines how to transform tool/composition output
// This is the unified, enhanced version supporting all mapping features
message OutputTransform {
  // Field name -> source mapping
  map<string, FieldSource> mappings = 1;
}

